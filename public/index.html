<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <!-- <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:;
    script-src 'self' 'unsafe-inline' 'unsafe-eval';
    style-src 'self' 'unsafe-inline';
    connect-src 'self' http://localhost:3001 https://api-student-delivery.greep.io https://*.greep.io wss://api-student-delivery.greep.io wss://*.greep.io;
    object-src 'none';
  "
    /> -->
    <meta
      name="description"
      content="Student Delivery System - Modern OTP-based delivery management"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/White.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>Greep SDS</title>
    <script>
      // PERMANENT FIX: Block postMessage errors BEFORE anything else loads
      (function () {
        "use strict";

        // Store original postMessage
        const originalPostMessage = window.postMessage;

        // Create intelligent wrapper function - only block problematic calls
        function safePostMessage(message, targetOrigin, transfer) {
          try {
            // Block MetaMask messages
            if (
              message &&
              typeof message === "object" &&
              message.type &&
              (message.type.includes("metamask") ||
                message.type.includes("ethereum"))
            ) {
              console.warn("MetaMask message blocked:", message.type);
              return;
            }

            // INTELLIGENT BLOCKING: Only block calls that will definitely cause errors
            if (
              targetOrigin === "undefined" || // String "undefined" - definitely problematic
              targetOrigin === "null" // String "null" - definitely problematic
            ) {
              console.warn(
                "üö´ Blocked postMessage with problematic targetOrigin:",
                targetOrigin
              );
              return;
            }

            // ALLOW calls with undefined/null targetOrigin but handle them safely
            if (
              !targetOrigin ||
              targetOrigin === undefined ||
              targetOrigin === null
            ) {
              console.log(
                "‚ö†Ô∏è Allowing postMessage with undefined/null targetOrigin (will use default):",
                targetOrigin
              );
              // Call with default targetOrigin instead of blocking
              return originalPostMessage.call(
                this,
                message,
                "*", // Use wildcard as safe default
                transfer
              );
            }

            // Additional type safety - but allow non-string with safe fallback
            if (typeof targetOrigin !== "string") {
              console.log(
                "‚ö†Ô∏è Allowing postMessage with non-string targetOrigin (will use default):",
                typeof targetOrigin,
                targetOrigin
              );
              // Call with default targetOrigin instead of blocking
              return originalPostMessage.call(
                this,
                message,
                "*", // Use wildcard as safe default
                transfer
              );
            }

            // Safe to call postMessage with original targetOrigin
            return originalPostMessage.call(
              this,
              message,
              targetOrigin,
              transfer
            );
          } catch (error) {
            console.warn(
              "‚ö†Ô∏è postMessage error caught but allowing to continue:",
              error.message
            );
            // Don't block - let it continue
            return;
          }
        }

        // Override at multiple levels to ensure nothing gets through
        window.postMessage = safePostMessage;

        // Also override at prototype level
        if (window.MessageEvent && window.MessageEvent.prototype) {
          const originalPostMessageProto =
            window.MessageEvent.prototype.postMessage;
          if (originalPostMessageProto) {
            window.MessageEvent.prototype.postMessage = safePostMessage;
          }
        }

        // Make it non-writable and non-configurable
        Object.defineProperty(window, "postMessage", {
          value: safePostMessage,
          writable: false,
          configurable: false,
        });

        console.log(
          "üõ°Ô∏è INTELLIGENT postMessage protection activated - allowing legitimate calls"
        );
      })();

      // Suppress React Router future flag warnings
      const originalWarn = console.warn;
      console.warn = function (...args) {
        const message = args[0];
        if (
          typeof message === "string" &&
          (message.includes("React Router Future Flag Warning") ||
            message.includes("v7_startTransition") ||
            message.includes("v7_relativeSplatPath"))
        ) {
          return;
        }
        originalWarn.apply(console, args);
      };

      // Block MetaMask connections
      if (typeof window !== "undefined") {
        // Override ethereum object to prevent MetaMask connections
        Object.defineProperty(window, "ethereum", {
          get: function () {
            console.warn("MetaMask connection blocked");
            return undefined;
          },
          set: function () {
            console.warn("MetaMask connection blocked");
          },
        });
      }

      // INTELLIGENT ERROR HANDLING: Log errors but don't block functionality
      window.addEventListener("error", function (event) {
        if (
          event.error &&
          event.error.message &&
          event.error.message.includes("postMessage")
        ) {
          console.log(
            "‚ö†Ô∏è postMessage error detected (allowing to continue):",
            event.error.message
          );
          // Don't prevent default - let it continue
        }
      });

      window.addEventListener("unhandledrejection", function (event) {
        if (
          event.reason &&
          event.reason.message &&
          event.reason.message.includes("postMessage")
        ) {
          console.log(
            "‚ö†Ô∏è postMessage promise rejection detected (allowing to continue):",
            event.reason.message
          );
          // Don't prevent default - let it continue
        }
      });

      // Block MetaMask extension messages and handle invalid postMessage calls
      const originalPostMessage = window.postMessage;
      window.postMessage = function (message, targetOrigin, transfer) {
        // Log all postMessage calls for debugging
        console.log("üîç postMessage called with:", {
          message,
          targetOrigin,
          transfer,
        });

        try {
          // Block MetaMask messages
          if (
            message &&
            typeof message === "object" &&
            message.type &&
            (message.type.includes("metamask") ||
              message.type.includes("ethereum"))
          ) {
            console.warn("MetaMask message blocked:", message.type);
            return;
          }

          // Validate targetOrigin before calling postMessage
          if (
            !targetOrigin ||
            targetOrigin === "undefined" ||
            targetOrigin === "null"
          ) {
            console.warn(
              "‚ö†Ô∏è Blocked postMessage with invalid targetOrigin:",
              targetOrigin
            );
            return;
          }

          // Additional safety checks
          if (typeof targetOrigin !== "string" || targetOrigin.trim() === "") {
            console.warn(
              "‚ö†Ô∏è Blocked postMessage with non-string targetOrigin:",
              targetOrigin
            );
            return;
          }

          // Safe to call postMessage
          console.log(
            "‚úÖ postMessage call allowed with valid targetOrigin:",
            targetOrigin
          );
          return originalPostMessage.call(
            this,
            message,
            targetOrigin,
            transfer
          );
        } catch (error) {
          console.warn(
            "‚ö†Ô∏è postMessage error caught and prevented:",
            error.message
          );
          return;
        }
      };

      // Add global error handler for postMessage errors
      window.addEventListener("error", function (event) {
        console.log("üîç Global error event:", event);

        if (
          event.error &&
          event.error.message &&
          event.error.message.includes("postMessage")
        ) {
          console.warn(
            "‚ö†Ô∏è Global postMessage error caught:",
            event.error.message
          );
          event.preventDefault();
          return false;
        }

        // Also catch any SyntaxError related to postMessage
        if (event.message && event.message.includes("postMessage")) {
          console.warn(
            "‚ö†Ô∏è Global postMessage syntax error caught:",
            event.message
          );
          event.preventDefault();
          return false;
        }
      });

      // Also handle unhandled promise rejections
      window.addEventListener("unhandledrejection", function (event) {
        if (
          event.reason &&
          event.reason.message &&
          event.reason.message.includes("postMessage")
        ) {
          console.warn(
            "‚ö†Ô∏è Global postMessage promise rejection caught:",
            event.reason.message
          );
          event.preventDefault();
          return false;
        }
      });

      // Additional safety: Override postMessage at prototype level
      if (window.MessageEvent && window.MessageEvent.prototype) {
        const originalPostMessageProto =
          window.MessageEvent.prototype.postMessage;
        if (originalPostMessageProto) {
          window.MessageEvent.prototype.postMessage = function (
            message,
            targetOrigin,
            transfer
          ) {
            console.log("üîç MessageEvent postMessage called with:", {
              message,
              targetOrigin,
              transfer,
            });

            if (
              !targetOrigin ||
              targetOrigin === "undefined" ||
              targetOrigin === "null"
            ) {
              console.warn(
                "‚ö†Ô∏è Blocked MessageEvent postMessage with invalid targetOrigin:",
                targetOrigin
              );
              return;
            }

            try {
              return originalPostMessageProto.call(
                this,
                message,
                targetOrigin,
                transfer
              );
            } catch (error) {
              console.warn(
                "‚ö†Ô∏è MessageEvent postMessage error caught:",
                error.message
              );
              return;
            }
          };
        }
      }

      // Final safety: Monitor for any postMessage calls
      console.log("üõ°Ô∏è postMessage protection activated successfully");
    </script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
